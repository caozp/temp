# 阻塞队列

阻塞队列 常用于生成者和消费者的场景

BlockingQueue的核心方法：

获取数据:

- poll(time)方法用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回null；否则返回取得的元素；
- take方法用来从队首取元素，如果队列为空，则等待；

放入数据:

- offer(E o,long timeout,TimeUnit unit)方法用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true；
- offer 可以向队尾存入元素返回true，否则返回false，不阻塞执行方法的线程
- put方法用来向队尾存入元素，如果队列满，则等待；





Java提供了7中阻塞队列：

- ArrayBlockingQueue  一个由数组支持的有界阻塞队列
- LinkedBlockingQueue   链表结构的有界队列。生产端和消费端分别采用了独立的锁来控制数据同步。需要指定容量大小，否则默认无限大小的容量
- PriorityBlockingQueue 支持优先级的无界队列，是PriorityQueue的线程安全版
- DelayQueue  支持延迟获取元素的无界阻塞队列。元素需要实现delayed接口。创建元素时，可以指定元素的到期时间，只有元素到期时才能取走
- SynchronousQueue  内部没有容量，但是由于一个插入操作总是对应一个移除操作，反过来同样需要满足。那么一个元素就不会在SynchronousQueue 里面长时间停留，一旦有了插入线程和移除线程，元素很快就从插入线程移交给移除线程。也就是说这更像是一种信道（管道），资源从一个方向快速传递到另一方 向。显然这是一种**快速传递元素的方式**，也就是说在这种情况下元素总是以最快的方式从插入着（生产者）传递给移除着（消费者），这在多任务队列中是最快处理任务的方式。在线程池里的一个**典型应用**是Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收
- LinkedTransferQueue 链表结构的无界组阻塞队列。它实现了TransferQueue接口。
  - transfer：若当前存在一个正在等待获取消费者线程，则立刻将元素传递给消费者。如果没有消费者，将元素插入到队列尾部，并且等待进入阻塞队列，直到有消费者线程取走元素
  - tryTransfer 若当前存在一个正在等待获取的消费者线程，则立刻将元素传递给消费者，若不存在，直接返回false，并且不进入队列，这是不阻塞的操作。
  - tryTransfer(E e,long timeout,TimeUnit unit) 若当前存在一个正在等待获取的消费者线程，则立刻将元素给消费者，若不存在，则将元素插入到队列尾部，并且等待消费者线程取走，若在规定超时时间未被消费者获取走，则返回false
- LinkedBlockingDeque 双向的链表结构组成的阻塞队列。可以在两端插入和移除元素