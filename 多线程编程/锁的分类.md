# 锁分类

### 乐观锁和悲观锁

悲观锁——指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。

乐观锁——每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁



### 公平锁和非公平锁

公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。 而非公平锁则在运行时闯入，也就是先来不一定先得。

ReentrantLock 提供了公平和非公平锁的实现。 如果构造函数不传递参数，则默认是非公平锁。

在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。



### 独占锁和共享锁

根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。

独占锁保证任何时候都只有一个线程能得到锁，`ReentrantLock` 就是以独占方式实现 的。 

共享锁则可以同时由多个线程持有，例如 `ReadWriteLock` 读写锁，它允许一个资源可 以被多线程同时进行读操作。它是一种乐观锁，它放宽了加锁的条件



### 可重入锁

当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己己经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可重入的



### 自旋锁

以当一个线程在获取锁（比如独占锁）失败后，会被切换到内核状态而被挂起。 当该线程获取到锁时又需要将其切换 到内核状态而唤醒该线程。 而从用户状态切换到内核状态的开销是比较大的，在一定程度 上会影响并发性能。自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有， 它不马上阻塞自己，在不放弃 CPU 使用权的情况下，多次尝试获取，很有可能在后面几次尝试中其他线程己经释 放了锁。 如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。 由此看来自 旋锁是使用 CPU 时间换取线程阻塞与调度的开销，但是很有可能这些 CPU 时间 白白浪费了
